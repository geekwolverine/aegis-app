{"version":3,"file":"753.js","mappings":"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","sources":["webpack://microlib-example/./src/adapters/address-adapter.js","webpack://microlib-example/./src/adapters/payment-adapter.js","webpack://microlib-example/./src/adapters/shipping-adapter.js","webpack://microlib-example/./src/adapters/event-adapter.js","webpack://microlib-example/./src/adapters/inventory-adapter.js","webpack://microlib-example/./src/services/event-service.js"],"sourcesContent":["\"use strict\";\n\n/**\n * @typedef {import('../domain/order').Order} Order\n * @typedef {string} address\n * @callback adapterFactory\n * @param {service} service\n * @returns {function({model:Order})} - verified/corrected address\n */\n\n/**\n *\n * @type {adapterFactory}\n * @param {import(\"../services/address-service\").Address} service\n */\nexport function validateAddress(service) {\n  return async function (options) {\n    const {\n      model: order,\n      args: [callback],\n    } = options;\n\n    try {\n      const shippingAddress = await service.validateAddress(\n        order.decrypt().shippingAddress\n      );\n      const update = await callback(options, { shippingAddress });\n      return update;\n    } catch (error) {\n      console.error({ func: validateAddress.name, error, options });\n    }\n  };\n}\n","'use strict'\n\n/**\n * @typedef {import('../domain/order').Order} Order\n * @callback adapterFactory\n * @param {service} service\n * @returns {function({model:Order,parms:any[]})}\n */\n\n/**\n * @type {adapterFactory}\n * @param {import(\"../services/payment-service\").PaymentService} service\n */\nexport function authorizePayment (service) {\n  return async function (options) {\n    const {\n      model: order,\n      args: [callback]\n    } = options\n\n    const paymentAuthorization = await service.authorizePayment(\n      order.orderNo,\n      12.0,\n      'src',\n      'ibm',\n      false\n    )\n    const paymentStatus = 'APPROVED'\n    return callback(options, { paymentStatus })\n  }\n}\n\n/**\n * @type {adapterFactory}\n */\nexport function completePayment (service) {\n  return async function (options) {\n    const {\n      model: order,\n      args: [callback]\n    } = options\n    const confirmationCode = await service.completePayment(order)\n    const newOrder = await callback(options, { confirmationCode })\n    return newOrder\n  }\n}\n/**\n * @type {adapterFactory}\n */\nexport function refundPayment (service) {\n  return async function (options) {\n    const {\n      model: order,\n      args: [callback]\n    } = options\n    await service.refundPayment(order)\n    const newOrder = await callback(options)\n    return newOrder\n  }\n}\n","\"use strict\";\n\n/**\n * @callback portCallback\n * @param {{options:{}}}\n * @param {{payload:{[key]:string}}}\n */\n\n/**\n * @typedef {string} message\n * @callback eventCallback\n * @param {string} message\n * @param {{\n *  unsubscribe:function(),\n *  filter:function(message):boolean\n * }} subscription\n */\n\n/**\n * @typedef {import('../domain/order').Order} Order\n */\n\n/**\n * @typedef {import(\"../services/shipping-service\").shippingService} shippingService\n */\n\n/**\n * @typedef {{\n *  listen:function(topic,RegExp,portCallback)\n *  notify:function(topic,eventCallback)\n * }} event\n */\n\n/**\n * @callback adapterFactory\n * @param {service} service\n * @returns {function({model:Order,args:[portCallback]}):Order}\n */\n\nconst ORDER_SERVICE = \"orderService\";\nconst ORDER_TOPIC = \"orderChannel\";\n\nconst handleError = (error, reject = null, func = null) => {\n  console.error({ file: __filename, func, error });\n  if (reject) reject(error);\n};\n\n/**\n * Call `shipOrder` to request shipment of the order items.\n * @param {import('../services/shipping-service').shippingService} service\n * @type {adapterFactory}\n * @returns {function(options):Promise<Order>}\n * Return a promise that is resolved once we receive\n * a response message from the shipping service. Start\n * listening for the response first and then send the\n * request message.\n *\n */\nexport function shipOrder(service) {\n  return async function (options) {\n    const {\n      model: order,\n      args: [callback],\n    } = options;\n\n    /**\n     * Called by the event listener when the shipOrder\n     * response message arrives. Resolve the promise\n     * the caller has been waiting on since we sent\n     * the request message.\n     * @param {function(Order)} resolve\n     * @param {function(Error)} reject\n     * @returns {function(message):Promise<Order>}\n     */\n    function shipOrderCallback(resolve, reject) {\n      return async function ({ message }) {\n        try {\n          const event = JSON.parse(message);\n          console.debug(\"received event... \", event);\n          const payload = service.getPayload(shipOrder.name, event);\n          const updated = await callback(options, payload);\n          resolve(updated);\n        } catch (error) {\n          handleError(error, reject, shipOrderCallback.name);\n        }\n      };\n    }\n\n    /**\n     * Send the shipOrder event to the shipping service.\n     */\n    function callShipOrder() {\n      return order.notify(\n        service.topic,\n        JSON.stringify(\n          service.shipOrder({\n            shipTo: order.decrypt().shippingAddress,\n            shipFrom: order.pickupAddress,\n            lineItems: order.orderItems,\n            signature: order.signatureRequired,\n            externalId: order.orderNo,\n            requester: ORDER_SERVICE,\n            respondOn: ORDER_TOPIC,\n          })\n        )\n      );\n    }\n\n    return new Promise(function (resolve, reject) {\n      return order\n        .listen({\n          once: true,\n          model: order,\n          id: order.orderNo,\n          topic: ORDER_TOPIC,\n          filters: [order.orderNo, \"orderShipped\", \"shipmentId\"],\n          callback: shipOrderCallback(resolve, reject),\n        })\n        .then(callShipOrder)\n        .catch(handleError);\n    });\n  };\n}\n\n/**\n * @param {import('../services/shipping-service').shippingService} service\n * @type {adapterFactory}\n */\nexport function trackShipment(service) {\n  return async function (options) {\n    const {\n      model: order,\n      args: [callback],\n    } = options;\n\n    /**\n     *\n     * @param {function(Order)} resolve resolve the promise\n     * @param {function(Error)} reject reject promise\n     */\n    function trackShipmentCallback(resolve, reject) {\n      return async function ({ message, subscription }) {\n        try {\n          const event = JSON.parse(message);\n          console.debug(\"received event...\", event);\n          const payload = service.getPayload(trackShipment.name, event);\n          const updated = await callback(options, payload);\n          if (updated.trackingStatus === \"orderDelivered\") {\n            subscription.unsubscribe();\n            resolve(updated);\n          }\n        } catch (error) {\n          handleError(error, reject, trackShipment.name);\n        }\n      };\n    }\n\n    function callTrackShipment() {\n      return order.notify(\n        service.topic,\n        JSON.stringify(\n          service.trackShipment({\n            shipmentId: order.shipmentId,\n            externalId: order.orderNo,\n            requester: ORDER_SERVICE,\n            respondOn: ORDER_TOPIC,\n          })\n        )\n      );\n    }\n\n    return new Promise(async function (resolve, reject) {\n      return order\n        .listen({\n          once: false,\n          model: order,\n          id: order.orderNo,\n          topic: ORDER_TOPIC,\n          filters: [order.orderNo, \"trackingId\", \"trackingStatus\"],\n          callback: trackShipmentCallback(resolve, reject),\n        })\n        .then(callTrackShipment)\n        .catch(handleError);\n    });\n  };\n}\n\n/**\n * @param {import('../services/shipping-service').shippingService} service\n * @type {adapterFactory}\n */\nexport function verifyDelivery(service) {\n  return async function (options) {\n    const {\n      model: order,\n      args: [callback],\n    } = options;\n\n    /**\n     *\n     * @param {function(Order)} resolve\n     * @param {function(Error)} reject\n     * @returns\n     */\n    function verifyDeliveryCallback(resolve, reject) {\n      return async function ({ message }) {\n        try {\n          const event = JSON.parse(message);\n          console.debug(\"received event...\", event);\n          const payload = service.getPayload(verifyDelivery.name, event);\n          const updated = await callback(options, payload);\n          resolve(updated);\n        } catch (e) {\n          handleError(e, reject, verifyDeliveryCallback.name);\n        }\n      };\n    }\n\n    function callVerifyDelivery() {\n      return order.notify(\n        service.topic,\n        JSON.stringify(\n          service.verifyDelivery({\n            trackingId: order.trackingId,\n            externalId: order.orderNo,\n            requester: ORDER_SERVICE,\n            respondOn: ORDER_TOPIC,\n          })\n        )\n      );\n    }\n\n    return new Promise(async function (resolve, reject) {\n      return order\n        .listen({\n          once: true,\n          model: order,\n          id: order.orderNo,\n          topic: \"orderChannel\",\n          filters: [order.orderNo, \"deliveryVerified\", \"proofOfDelivery\"],\n          callback: verifyDeliveryCallback(resolve, reject),\n        })\n        .then(callVerifyDelivery)\n        .catch(handleError);\n    });\n  };\n}\n","\"use strict\";\n\n/**\n * @typedef {import('../domain').Model} Model\n * @typedef {string} serviceName\n *\n * @typedef {Object} EventMessage\n * @property {serviceName} eventSource\n * @property {serviceName|\"broadcast\"} eventTarget\n * @property {\"command\"|\"commandResponse\"|\"notification\"|\"import\"} eventType\n * @property {string} eventName\n * @property {string} eventTime\n * @property {string} eventUuid\n * @property {NotificationEvent|ImportEvent|CommandEvent} eventData\n *\n * @typedef {object} ImportEvent\n * @property {\"service\"|\"model\"|\"adapter\"} type\n * @property {string} url\n * @property {string} path\n * @property {string} importRemote\n *\n * @typedef {object} NotificationEvent\n * @property {string|} message\n * @property {\"utf8\"|Uint32Array} encoding\n *\n * @typedef {Object} CommandEvent\n * @property {string} commandName\n * @property {string} commandResp\n * @property {*} commandArgs\n */\n\n/**\n * @typedef {{\n *  filter:function(message):Promise<void>,\n *  unsubscribe:function()\n * }} Subscription\n * @typedef {string|RegExp} topic\n * @callback eventHandler\n * @param {string} eventData\n * @typedef {eventHandler} notifyType\n * @typedef {{\n * listen:function(topic, x),\n * notify:notifyType\n * }} EventService\n * @callback adapterFactory\n * @param {EventService} service\n * @returns {function(topic, eventHandler)}\n */\nimport { Event } from \"../services/event-service\";\n\n/**\n * @type {Map<any,Map<string,*>>}\n */\nconst subscriptions = new Map();\n\n/**\n * Test the filter.\n * @param {string} message\n * @returns {function(string|RegExp):boolean} did the filter match?\n */\nfunction filterMatches(message) {\n  return function (filter) {\n    const regex = new RegExp(filter);\n    const result = regex.test(message);\n    if (result)\n      console.debug({\n        func: filterMatches.name,\n        filter,\n        result,\n        message: message.substring(0, 100).concat(\"...\"),\n      });\n    return result;\n  };\n}\n\n/**\n * @typedef {string} message\n * @typedef {string|RegExp} topic\n * @param {{\n *  id:string,\n *  callback:function(message,Subscription),\n *  topic:topic,\n *  filter:string|RegExp,\n *  once:boolean,\n *  model:import(\"../domain\").Model\n * }} options\n */\nconst Subscription = function ({ id, callback, topic, filters, once, model }) {\n  return {\n    /**\n     * unsubscribe from topic\n     */\n    unsubscribe() {\n      subscriptions.get(topic).delete(id);\n    },\n\n    getId() {\n      return id;\n    },\n\n    getModel() {\n      return model;\n    },\n\n    getSubscriptions() {\n      return [...subscriptions.entries()];\n    },\n\n    /**\n     * Filter message and invoke callback\n     * @param {string} message\n     */\n    async filter(message) {\n      if (filters) {\n        // Every filter must match.\n        if (filters.every(filterMatches(message))) {\n          if (once) {\n            // Only looking for 1 msg, got it.\n            this.unsubscribe();\n          }\n          await callback({ message, subscription: this });\n          return;\n        }\n        // no match\n        return;\n      }\n      // no filters defined, just invoke the callback.\n      await callback({ message, subscription: this });\n    },\n  };\n};\n\n/**\n * Listen for external events with default event service if none specified.\n * @type {adapterFactory}\n * @param {import('../services/event-service').Event} [service] - has default service\n */\nexport function listen(service = Event) {\n  return async function (options) {\n    const {\n      model,\n      args: [arg],\n    } = options;\n\n    const subscription = Subscription({ model, ...arg });\n\n    if (subscriptions.has(arg.topic)) {\n      subscriptions.get(arg.topic).set(arg.id, subscription);\n      return subscription;\n    }\n\n    subscriptions.set(arg.topic, new Map().set(arg.id, subscription));\n\n    if (!service.listening) {\n      service.listen(/Channel/, async function ({ topic, message }) {\n        if (subscriptions.has(topic)) {\n          subscriptions.get(topic).forEach(async subscription => {\n            await subscription.filter(message);\n          });\n        }\n      });\n    }\n    return subscription;\n  };\n}\n\n/**\n * @type {adapterFactory}\n * @returns {function(topic, eventData)}\n */\nexport function notify(service = Event) {\n  return async function ({ model, args: [topic, message] }) {\n    console.debug(\"sending...\", { topic, message: JSON.parse(message) });\n    await service.notify(topic, message);\n    return model;\n  };\n}\n","\"use strict\";\n\n/**\n * @typedef {string|RegExp} topic\n * @callback eventCallback\n * @param {string} message\n * @param {{\n *  getModel:function():object,\n *  unsubscribe:function()\n * }} subscription\n * @typedef {eventCallback} shipOrderType\n * @param topic,\n * @param eventCallback\n * @typedef {{\n *  shipOrder:shipOrderType,\n *  trackShipment:function(),\n *  verifyDelivery:function()\n * }} InventoryAdapter\n * @typedef {import('../domain/order').Order} Order\n * @typedef {InventoryAdapter} service \n * @typedef {{\n *  listen:function(topic,RegExp,eventCallback)\n *  notify:function(topic,eventCallback)\n * }} event\n * @callback adapterFactory\n * @param {service} service\n * @param {event} event\n * @returns {function({\n * model:Order,\n * resolve:function()\n * ,args:[\n * eventCallback, \n * options:{}]\n * })}\n   \n }]})} \n *\n */\n\n/**\n * @type {adapterFactory}\n */\nexport function pickOrder(service) {\n  return function (options) {\n    const {\n      model: order,\n      args: [callback],\n    } = options;\n\n    return new Promise(function (resolve, reject) {\n      // start listening first then send the event\n      return order\n        .listen({\n          once: true,\n          model: order,\n          id: order.orderNo,\n          topic: \"orderChannel\",\n          filters: [order.orderNo, \"orderPicked\", \"warehouse_addr\"],\n          callback: async ({ message }) => {\n            try {\n              const event = JSON.parse(message);\n              console.log(\"recieved event: \", event);\n              const pickupAddress = event.eventData.warehouse_addr;\n              const newOrder = await callback(options, { pickupAddress });\n              resolve(newOrder); // hold promise until we get an answer\n            } catch (error) {\n              reject(error);\n            }\n          },\n        })\n        .then(() => {\n          return order.notify(\n            \"inventoryChannel\",\n            JSON.stringify({\n              eventType: \"Command\",\n              eventTime: new Date().toUTCString(),\n              eventSource: \"orderService\",\n              eventData: {\n                replyChannel: \"orderChannel\",\n                commandName: \"pickOrder\",\n                commandArgs: {\n                  lineItems: order.orderItems,\n                  externalId: order.orderNo,\n                },\n              },\n            })\n          );\n        })\n        .catch((reason) => {\n          throw new Error(reason);\n        });\n    });\n  };\n}\n","\"use strict\";\n\nimport { Kafka } from \"kafkajs\";\n\nconst brokers = process.env.KAFKA_BROKERS || \"localhost:9092\";\nconst topics = new RegExp(process.env.KAFKA_TOPICS) || /Channel/;\nconst groupId = (process.env.KAFKA_GROUP_ID || \"MicroLib\") + process.pid;\n\nconst kafka = new Kafka({\n  clientId: \"MicroLib\",\n  brokers: brokers.split(\",\"),\n});\n\nconst consumer = kafka.consumer({ groupId });\nconst producer = kafka.producer();\n\n/**\n * @typedef {EventService}\n */\nexport const Event = {\n  listening: false,\n  topics,\n\n  /**\n   * Implements event consumer service.\n   * @param {string|RegExp} topic\n   * @param {function({message, topic})} callback\n   */\n  async listen(topic, callback) {\n    try {\n      await consumer.connect();\n      await consumer.subscribe({ topic, fromBeginning: true });\n      this.listening = true;\n      await consumer.run({\n        eachMessage: async ({ topic, message }) => {\n          try {\n            callback({\n              topic,\n              message: message.value.toString(),\n            });\n          } catch (error) {\n            console.error(error);\n          }\n        },\n      });\n    } catch (error) {\n      console.error(error);\n    }\n  },\n\n  /**\n   * Implemements event producer service.\n   * @param {string|RegExp} topic\n   * @param {string} message\n   */\n  async notify(topic, message) {\n    try {\n      await producer.connect();\n      await producer.send({\n        topic: topic,\n        messages: [{ value: message }],\n      });\n      await producer.disconnect();\n    } catch (error) {\n      console.error({ func: this.notify.name, error });\n    }\n  },\n};\n"],"names":["validateAddress","service","options","order","model","args","callback","decrypt","shippingAddress","update","console","error","func","name","authorizePayment","orderNo","paymentStatus","completePayment","confirmationCode","newOrder","refundPayment","ORDER_SERVICE","ORDER_TOPIC","handleError","reject","file","__filename","shipOrder","shipOrderCallback","callShipOrder","notify","topic","JSON","stringify","shipTo","shipFrom","pickupAddress","lineItems","orderItems","signature","signatureRequired","externalId","requester","respondOn","resolve","message","event","parse","debug","payload","getPayload","updated","Promise","listen","once","id","filters","then","trackShipment","trackShipmentCallback","callTrackShipment","shipmentId","subscription","trackingStatus","unsubscribe","verifyDelivery","verifyDeliveryCallback","callVerifyDelivery","trackingId","subscriptions","Map","filterMatches","filter","result","RegExp","test","substring","concat","Subscription","get","getId","getModel","getSubscriptions","entries","every","Event","arg","has","set","listening","forEach","pickOrder","log","eventData","warehouse_addr","eventType","eventTime","Date","toUTCString","eventSource","replyChannel","commandName","commandArgs","reason","Error","brokers","process","env","KAFKA_BROKERS","topics","KAFKA_TOPICS","groupId","KAFKA_GROUP_ID","pid","kafka","Kafka","clientId","split","consumer","producer","connect","subscribe","fromBeginning","run","eachMessage","value","toString","send","messages","disconnect"],"sourceRoot":""}